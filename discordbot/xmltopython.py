from xml.etree import ElementTree as ET
from tkinter import filedialog
import tkinter as tk
import json
import sys
import os
import re

MEMBER_EVENT_TYPES = ["on_member_join", "on_member_leave"]

def simplify_xml(xml_string):
    # Remove id, x, and y attributes
    pattern = r'\s(id|x|y)="[^"]*"'
    simplified_xml = re.sub(pattern, '', xml_string)
    return simplified_xml.replace('<xml xmlns="https://developers.google.com/blockly/xml">', "<xml>")

def open_file():
    file_path = filedialog.askopenfilename(
        title="Select a file",
        filetypes=[("All files", "*.*"), ("Text files", "*.txt")]
    )
    if file_path:
        # Here you can add code to process the selected file
        # For example, reading its contents:
        with open(file_path, 'r', encoding="utf-8") as file:
            return file.read()
        
def format_next(block, indent=4):
    """
    Recursively formats the 'next' block and its children.
    """
    next_code = ""
    current_indent = " " * indent
    
    if block["type"] == "send_message":
        message = block["message"]
        channel_type = block["channel"]["type"]
        if channel_type == "channel_context":
            next_code += f'{current_indent}channel = interaction.channel\n'
        elif channel_type == "channel_by_id":
            channel_id = block["channel"]["channel_id"]
            next_code += f'{current_indent}channel = client.get_channel({channel_id})\n'
        next_code += f'{current_indent}if channel:\n'
        next_code += f'{current_indent * 2}await channel.send("{message}")\n'
    elif block["type"] == "respond":
        message = block["message"]
        next_code += f'{current_indent}await interaction.response.send_message("{message}")\n'
    if "next" in block:
        next_code += format_next(block["next"], indent=4)
    
    return next_code

def xml_to_dict(element):
    result = {}
    result['type'] = element.attrib.get('type', element.tag)
    
    for child in element:
        if child.tag == 'field':
            result[child.attrib['name'].lower()] = child.text
        elif child.tag == 'value':
            result[child.attrib['name'].lower()] = xml_to_dict(child[0])
        elif child.tag == 'next':
            result['next'] = xml_to_dict(child[0])
        else:
            child_result = xml_to_dict(child)
            if child.tag in result:
                if not isinstance(result[child.tag], list):
                    result[child.tag] = [result[child.tag]]
                result[child.tag].append(child_result)
            else:
                result[child.tag] = child_result
    
    return result

def makediscordpy(blocks):
    preemble = "cwd = os.path.dirname(os.path.abspath(sys.argv[0]))"
    end = ""
    commands = ""
    tree = ""
    for block in blocks["blocks"]:
        if block["type"] == "token":
            end += f"client.run('{block['name']}')"
        elif block["type"] == "command":
            commands += f"""
@app_commands.command(description="AutoCommand generated by QWERTZdiscord")
async def {block["name"]}(interaction: discord.Interaction):
    # Command logic
"""
            
            # Now process any "next" block recursively
            if "next" in block:
                commands += format_next(block["next"], indent=4)
            tree += f"tree.add_command({block['name']})"
        elif block["type"] in MEMBER_EVENT_TYPES:
            commands += f"""
@bot.event
async def {block['type']}(member):

"""
            # Now process any "next" block recursively
            if "next" in block:
                commands += format_next(block["next"], indent=4)
    structure = f"""### Automatically generated by QWERTZ_EXE https://qwertz.app/discordbot

import os
import sys
import discord
from discord import app_commands

{preemble}

intents = discord.Intents.all()
activity = discord.Activity(type=discord.ActivityType.listening, name="Made by QWERTZ")

client = discord.AutoShardedClient(shard_count=1,intents=intents, activity=activity)
tree = app_commands.CommandTree(client)

@client.event
async def on_ready():
    await tree.sync()

{commands}

{tree}

{end}
"""
    return structure

if __name__ == '__main__':

    if len(sys.argv) < 2:

        if os.name == 'nt':
            from ctypes import windll
            windll.shcore.SetProcessDpiAwareness(1)

        # Create the main window
        root = tk.Tk()
        root.withdraw()  # Hide the main window

        # Open the file dialog immediately
        xml_input = open_file()

        # Close the program after file selection
        root.destroy()

    else:
        with open(os.path.abspath(sys.argv[1]), 'r', encoding="utf-8") as file:
            xml_input =  file.read()

    simplified_xml = simplify_xml(xml_input)
    #print(simplified_xml)

    root = ET.fromstring(simplified_xml)

    result = {'blocks': [xml_to_dict(block) for block in root]}
    
    #print(json.dumps(result, indent=2))

    x = makediscordpy(result)

    print(x)